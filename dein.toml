
# Vim Settings
# ========================================
hook_add = '''
'''

# Filetype Specific
# ----------------------------------------
[ftplugin]
_ = ''

help = '''
nnoremap <buffer> <CR> <C-]>
nnoremap <buffer> <BS> <C-T>
nnoremap <buffer> o /'\l\{2,\}'<CR>
nnoremap <buffer> O ?'\l\{2,\}'<CR>
nnoremap <buffer> s /\|\zs\S\+\ze\|<CR>
nnoremap <buffer> S ?\|\zs\S\+\ze\|<CR>
'''


# The Plugin Manager
# ========================================
[[plugins]]
repo = 'Shougo/dein.vim'
lazy = true
on_cmd = 'DeinSource'
hook_add = '''
" for ftplugin to be updated on vimrc change
let g:dein#auto_recache = v:true

let s:token_file = stdpath('data') . '.dein_github_update_token'
if filereadable(s:token_file)
  let g:dein#install_github_api_token = readfile(s:token_file,'', 1)
  autocmd VimEnter * call dein#check_update()
endif

command! -nargs=1 DeinSource call dein#source(<f-args>)

" echo 'dein.vim hook_add loaded'
'''

# vim-plug like ui
[[plugins]]
repo = 'wsdjeg/dein-ui.vim'
depends = 'dein.vim'
on_cmd = 'DeinUpdate'


# UI
# ========================================

# Prerequisites
# ----------------------------------------

[[plugins]]
repo = 'kyazdani42/nvim-web-devicons'
lazy = true
if = 'has("nvim")'


# Colorschemes
# ----------------------------------------
# colorschemeの設定は on_hook = 'VimEnter' ではだめらしい
# https://qiita.com/kawaz/items/ee725f6214f91337b42b#colorscheme-%E3%81%AF-vimenter-%E3%81%AB-nested-%E6%8C%87%E5%AE%9A%E3%81%A7%E9%81%85%E5%BB%B6%E8%A8%AD%E5%AE%9A%E3%81%99%E3%82%8B

[[plugins]]
repo = 'joshdick/onedark.vim'
lazy = true
is = '!has("nvim")'
hook_add = '''
autocmd config VimEnter * nested
      \ set background=dark |
      \ colorscheme onedark

" echo g:dein#plugin.name . ' hook_add loaded'
'''

repo = 'navarasu/onedark.nvim'
lazy = true
if = 'has("nvim")'
hook_add = '''
let g:disable_toggle_style = v:true
autocmd config VimEnter * nested
      \ set background=dark |
      \ colorscheme onedark

" echo g:dein#plugin.name . ' hook_add loaded'
'''

# [[plugins]]
# repo = 'marko-cerovac/material.nvim'
# lazy = true
# if = 'has("nvim")'
# hook_add = '''
# let g:material_style = 'palenight'
# let g:material_italic_comments = v:true
# let g:material_borders = v:true

# command! MaterialCycle lua require('material.functions').toggle_style()<CR>

# autocmd config VimEnter * nested
#       \ set background=dark |
#       \ colorscheme material

# " echo g:dein#plugin.name . ' hook_add loaded'
# '''

# [[plugins]] repo = 'ayu-theme/ayu-vim'
# [[plugins]] repo = 'sonph/onehalf' rtp = 'vim'
# [[plugins]] repo = 'jacoborus/tender.vim'
# [[plugins]] repo = 'romainl/Apprentice'
# [[plugins]] repo = 'drewtempelmeyer/palenight.vim'
# [[plugins]] repo = 'ErichDonGubler/vim-sublime-monokai'

# # One terminal plugin to rule them all (eventually).
# [[plugins]]
# repo = 'LoricAndre/OneTerm.nvim'
# if = 'has("nvim")'

# [[plugins]]
# repo = 'nvim-lua/plenary.nvim'
# lazy = false

# # nvim-tree.lua: file system explorer
# # ----------------------------------------
# [[plugins]]
# repo = 'kyazdani42/nvim-tree.lua'
# require = 'nvim-web-devicons'
# if = 'has("nvim")'

# # CHADTree: File Manager for Neovim, Better than NERDTree.
# # ----------------------------------------
# [[plugins]]
# repo = 'ms-jpq/chadtree'
# rev = 'chad'
# lazy = true
# on_cmd = ['CHADopen', 'CHADhelp']
# on_map = 'sl'
# build = 'python3 -m chadtree deps'
# depends = 'vim-devicons'
# hook_add = '''
# " open and focus current file Fern with sl (ls command, or Sidebar Ls)
# nnoremap <unique> sl :CHADopen --always-focus --version-ctl<CR>

# lua << EOF
# local chadtree_settings = {
#         xdg = true,
#         options = {
#           show_hidden  = true, -- show hidden files like .gitignore
#         },
#         ignore = {
#           name_exact = {}, -- ignore nothing
#         },
#         view = {
#           width = 30,
#         },
#         keymap = {
#           -- Window management
#           quit = {'<Esc>', 'q', 'sl'},
#           bigger = {'+', '='},
#           smaller = {'-', ';'},
#           refresh = {'<C-r>', 'g'},
#           -- Rerooting CHADTree
#           --
#           change_dir = {'CD'},
#           change_focus = {'cd'},
#           change_focus_up = {'..'},
#           -- Open file / folder
#           primary = {'<CR>', '<LeftMouse>'}, -- Open file at cursor or toggle folder
#           secondary = {'<TAB>', '<2-LeftMouse>'}, -- Open file at cursor, keep cursor in CHADTree's window.
#           tertiary = {'<m-enter>', '<middlemouse>'},
#           v_split = {'v'},
#           h_split = {'s'},
#           open_sys = {'o'}, -- xdg-open
#           collapse = {'h', '<Left>'},
#           -- Doing things with cursor
#           refocus = {'~'}, -- Put cursor at the root of CHADTree
#           jump_to_current = {'%'},
#           stat = {'a'}, -- 'all', ls -l
#           copy_name = {'yy'}, -- '/foo/bar/baz.txt' Copy paths of files under cursor or visual block.
#           copy_basename = {'n'}, -- 'baz.txt' Copy names of files under cursor or visual block.
#           -- Filtering
#           filter = {'f'},
#           clear_filter = {'F'},
#           -- Selecting
#           ['select'] = {'m'}, -- 'mark'
#           clear_selection = {'u'}, -- 'unmark'
#           -- File operations
#           new = {'+'}, -- Files ending with platform specifc path seperator will be folders.
#           rename = {'r'},
#           copy = {'p'}, -- Paste the selected files to location under cursor.
#           cut = {'x'}, -- Move the selected files to location under cursor.
#           delete = {'delete!'}, -- Delete the selected files. Items deleted cannot be recovered.
#           trash = {'dd'}, -- trash-put
#           toggle_hidden = {'H'}, -- 'Hide' toggle hide/show of hidden files like .gitignore
#           toggle_follow = {}, -- toggle reveal current file in tree or not
#           toggle_version_control = {},
#         },
#         theme = {
#           text_colour_set = 'solarized_dark',
#         },
#       }
# vim.api.nvim_set_var("chadtree_settings", chadtree_settings)
# EOF

# function! s:CHAD_init() abort
#   " automaticly close if CHADTree buffer is shown in drawer
#   augroup CHAD-autoclose
#     autocmd!
#     autocmd Filetype ^(?!CHADTree).*$ CHADopen

#   augroup END
# endfunction

# autocmd config Filetype CHADTree call s:CHAD_init()

# " echo g:dein#plugin.name . ' hook_add loaded'
# '''

# # use icons
# [[plugins]]
# repo = 'ryanoasis/vim-devicons'
# lazy = true

# fern.vim: file system explorer
# ----------------------------------------
[[plugins]]
repo = 'lambdalisue/fern.vim'
lazy = true
on_ft = 'fern'
on_cmd = 'Fern'
depends = [
  'fern-renderer-nerdfont.vim',
  'fern-git-status.vim',
  'fern-mapping-git.vim',
  'fern-preview.vim',
  'FixCursorHold.nvim',
  'glyph-palette.vim',
  ]
hook_add = '''
let g:fern#drawer_width = g:sidebar_width

" use nerd fonts
let g:fern#renderer = 'nerdfont'

" vertical cursorline instead of curso
let g:fern#hide_cursor = v:true

" show hidden files
let g:fern#default_hidden = v:false

let g:fern#disable_default_mappings = v:true

" open and focus current file Fern with sl (Sidebar file explorer)
function! FernOpenGitRepoOrCwd() abort
  let cwd = getcwd()
  let path = finddir('.git/..', cwd . ';')
  if empty(path)
    let path = './'
  endif
  execute 'Fern -drawer -toggle -reveal=' . cwd . ' ' . path
endfunction
command! FernOpenGitRepoOrCwd call FernOpenGitRepoOrCwd()
nnoremap <unique> sx :FernOpenGitRepoOrCwd<CR>

function! s:fern_init() abort

  " Perform expand or collapse directory
  nmap <buffer><expr>
      \ <Plug>(fern-my-toggle)
      \ fern#smart#leaf(
      \   "\<Plug>(fern-action-collapse)",
      \   "\<Plug>(fern-action-expand)",
      \   "\<Plug>(fern-action-collapse)",
      \ )

  " expand directory on <Right>, collaps on <Left>
  nmap <buffer> <Right> <Plug>(fern-action-expand)
  nmap <buffer> <Left> <Plug>(fern-action-collapse)

  " don't go down when expanding a node
  nmap <buffer> <Plug>(fern-action-expand) <Plug>(fern-action-expand:stay)

  " Perform enter in explorer style but expand in drawer style
  nmap <buffer><expr>
        \ <Plug>(fern-my-open-or-toggle)
        \ fern#smart#leaf(
        \   "\<Plug>(fern-action-open)",
        \   "\<Plug>(fern-my-toggle)",
        \ )

  nmap <buffer><expr>
        \ <Plug>(fern-my-toggle-or-enter)
        \ fern#smart#drawer(
        \   "\<Plug>(fern-my-open-or-toggle)",
        \   "\<Plug>(fern-open-or-enter)",
        \ )
  nmap <buffer><expr>
        \ <Plug>(fern-my-collapse-or-leave)
        \ fern#smart#drawer(
        \   "\<Plug>(fern-action-collapse)",
        \   "\<Plug>(fern-action-leave)",
        \ )

  " Window management
  nmap <buffer> <C-c> :close 1
  nmap <buffer> q :close 1

"   bigger = {'+', '='},
"   smaller = {'-', ';'},
  nmap <buffer> <C-r> <Plug>(fern-action-reload:all)
    nmap <buffer> g <Plug>(fern-action-reload:all)

  " Rerooting fern
  " " run vim :cd on cursor
  nmap <buffer> CD <Plug>(fern-action-cd)
  " " change fern's root
  nmap <buffer> cd <Plug>(fern-action-enter)
  " " go up direcotry in fern
  nmap <buffer> .. <Plug>(fern-action-leave)

  " Open file / folder
  " " Open file at cursor or toggle folder
  nmap <buffer> <CR> <Plug>(fern-my-toggle-or-enter)
    nmap <buffer> <2-Leftmouse> <Plug>(fern-my-toggle-or-enter)
  " " preview files in window. (uses fern-preview.vim)
  nmap <buffer> <TAB> <Plug>(fern-action-preview:reveal)
    nmap <buffer> <RightRelease> <Plug>(fern-action-preview:reveal)
  nmap <buffer> s <Plug>(fern-action-open-split)
  nmap <buffer> v <Plug>(fern-action-open:vsplit)
  " " xdg-open
  nmap <buffer> o <Plug>(fern-action-open:system)
  " nmap <buffer> h <Plug>(fern-action-expand)
  " nmap <buffer> l <Plug>(fern-action-collapse)

  " Doing things with cursor
  " " reveal current file
  nnoremap <buffer> % :FernDo :
  " " '/foo/bar/baz.txt' Copy paths of files under cursor or visual block.
  nmap <buffer> yy <Plug>(fern-action-yank:bufname)
  " 'baz.txt' Copy names of files under cursor or visual block.
  nmap <buffer> n <Plug>(fern-action-yank:label)

  " Filtering
  nmap <buffer> f <Plug>(fern-action-grep)
  nmap <buffer> F <Plug>(fern-action-grep=)<CR>

  " Selecting
  " " 'mark'
  map <buffer> m <Plug>(fern-action-mark:set)
  " " 'unmark'
  map <buffer> um <Plug>(fern-action-mark:unset)
  nmap <buffer> Um <Plug>(fern-action-mark:clear)

  " File operations
  " " Files ending with platform specifc path seperator will be folders.
  nmap <buffer> + <Plug>(fern-action-new-path)
  " " Copy and paste the selected files to location under cursor.
  nmap <buffer> p
        \ <Plug>(fern-action-clipboard-copy)
        \ <Plug>(fern-action-clipboard-paste)
        \ <Plug>(fern-action-clipboard-clear)
  " " Cut and paste the selected files to location under cursor.
  nmap <buffer> x
        \ <Plug>(fern-action-clipboard-move)
        \ <Plug>(fern-action-clipboard-paste)
        \ <Plug>(fern-action-clipboard-clear)
  " " Open 'remaner'
  nmap <buffer> r <Plug>(fern-action-rename:bottom)
  " Delete the selected files. Items deleted cannot be recovered.
  " " 'trash-put'
  nmap <buffer> dd <Plug>(fern-action-trash)
  " " '!rm' cannot be restored
  nmap <buffer> delete! <Plug>(fern-action-delete)
  " " 'Hide' toggle hide/show of hidden files like .gitignore
  nmap <buffer> <Plug>(fern-action-hidden:toggle)

  " don't use Command Line Window
  nnoremap <buffer> : :

  " disable line numbers
  setlocal nonumber

  " automaticly close if fern buffer is shown in drawer
  function! s:fern_close_drawer(helper) abort
    if a:helper.sync.is_drawer()
      Fern -drawer -toggle ./
    endif
  endfunction
  augroup fern-autoclose
    autocmd!
    autocmd WinLeave fern://* call fern#helper#call(function('s:fern_close_drawer'))
  augroup END

endfunction
autocmd config Filetype fern call s:fern_init()

" clean leftover fern window from last session
" autocmd config SessionLoadPost ferm://* silent! bdelete <afile>

" echo g:dein#plugin.name . ' hook_add loaded'
'''

[[plugins]]
repo = 'lambdalisue/fern-git-status.vim'
lazy = true
depends = 'fern.vim'
hook_add = '''
" Disable the following options one by one if you encounter performance issues.
" " Disable listing ignored files/directories
" let g:fern_git_status#disable_ignored = 1
" " Disable listing untracked files
" let g:fern_git_status#disable_untracked = 1
" " Disable listing status of submodules
" let g:fern_git_status#disable_submodules = 1
" " Disable listing status of directories
" let g:fern_git_status#disable_directories = 1

" echo g:dein#plugin.name . ' hook_add loaded'
'''

[[plugins]]
repo = 'lambdalisue/fern-mapping-git.vim'
lazy = true
depends = ['fern-git-status.vim', 'fern.vim' ]

[[plugins]]
repo = 'yuki-yano/fern-preview.vim'
lazy = true
depends = 'fern.vim'

[[plugins]]
repo = 'lambdalisue/fern-renderer-nerdfont.vim'
lazy = false
depends = ['fern.vim', 'nerdfont.vim']
hook_add = '''
" echo g:dein#plugin.name . ' hook_add loaded'
'''

[[plugins]]
repo = 'lambdalisue/nerdfont.vim'
lazy = true


[[plugins]]
repo = 'lambdalisue/glyph-palette.vim'
lazy = true
hook_add = '''
" アイコンに色をつける
augroup my-glyph-palette
  autocmd!
  autocmd FileType fern call glyph_palette#apply()
  autocmd FileType nerdtree,startify call glyph_palette#apply()
augroup END
'''

# more snappiness for plugins using CusorHold event, such as:
# # coc.nvim, vim-gutter, tagbar, vim-devicons, vim-polyglot, etc.
[[plugins]]
repo = 'antoinemadec/FixCursorHold.nvim'
lazy = true
if = 'has("nvim")'


# Vista.vim: View and search LSP symbols, tags in Vim/NeoVim. (imenu-list like thingy)
# ----------------------------------------
[[plugins]]
repo = 'liuchengxu/vista.vim'
lazy = true
on_cmd = 'Vista'
hook_add = '''
" toggle Vista (Sidebar Vista)
nnoremap <unique> sv :Vista!!<CR>

let g:vista_sidebar_position='vertical topleft'
let g:vista_sidebar_width = g:sidebar_width

" How each level is indented and what to prepend.
" This could make the display more compact or more spacious.
" e.g., more compact: ["▸ ", ""]
" Note: this option only works for the kind renderer, not the tree renderer.
let g:vista_icon_indent = ["▸ ", ""]

" Executive used when opening vista sidebar without specifying it.
" See all the avaliable executives via `:" echo g:vista#executives`.
let g:vista_default_executive = 'ctags'

" Set the executive for some filetypes explicitly. Use the explicit executive
" instead of the default one for these filetypes when using `:Vista` without
" specifying the executive.
" let g:vista_executive_for = {
"   \ 'cpp': 'vim_lsp',
"   \ 'php': 'vim_lsp',
"   \ }

" Declare the command including the executable and options used to generate ctags output
" for some certain filetypes.The file path will be appened to your custom command.
" For example:
let g:vista_ctags_cmd = {
      \ 'haskell': 'hasktags -x -o - -c',
      \ }

" Ensure you have installed some decent font to show these pretty symbols, then you can enable icon for the kind.
let g:vista#renderer#enable_icon = 1

" The default icons can't be suitable for all the filetypes, you can extend it as you wish.
let g:vista#renderer#icons = {
\   "function": "\uf794",
\   "variable": "\uf71b",
\  }

function! s:vista_init() abort
  " automaticly close if fern buffer is shown in drawer
  augroup vista-autoclose
    autocmd!
    autocmd WinLeave __vista__ close 1
  augroup END
endfunction
autocmd config FileType vista call s:vista_init()

" echo g:dein#plugin.name . ' hook_add loaded'
'''


# Statusline
# ----------------------------------------

# lightline.vim: A light and configurable statusline/tabline plugin for Vim
[[plugins]]
repo = 'itchyny/lightline.vim'
lazy = false
if = '!has("nvim")'
hook_add = '''
let g:lightline = {
      \ 'colorscheme' : 'onedark'
      \ }

" echo g:dein#plugin.name . ' hook_add loaded'
'''

[[plugins]]
repo = 'hoob3rt/lualine.nvim'
lazy = true
if = 'has("nvim")'
augroup = 'config'
on_event = 'VimEnter'
depends = ['nvim-web-devicons', 'lsp-status.nvim']
hook_post_source = '''
lua << EOF
require('lualine').setup{
  options = {
    icons_enabled = true,
    theme = 'onedark',
    padding = 1, -- adds padding to the left and right of components
    left_padding = 1, -- adds padding to the left of components
    right_padding = 1, -- adds padding to the right of components
    upper = false, -- displays components in uppercase
    lower = false, -- displays components in lowercase
    format = nil, -- format function, formats component's output
    component_separators = {'', ''},
    section_separators = {'', ''},
    disabled_filetypes = {}
  },
  sections = {
    lualine_a = {
      'mode',
      icon = nil, -- displays icon in front of the component
      separator = nil, -- overwrites component_separators for component
      condition = nil, -- condition function, component is loaded when function returns true
      -- custom color for component in format
      -- color = {fg = '#rrggbb', bg= '#rrggbb', gui='style'}
      -- or highlight group
      -- color = "WarningMsg"
      color = nil
    },
    lualine_b = {'branch'},
    lualine_c = {'filename'},
    lualine_x = {require('lsp-status').status, 'encoding', 'fileformat', 'filetype'},
    lualine_y = {'progress'},
    lualine_z = {'location'}
  },
  inactive_sections = {
    lualine_a = {},
    lualine_b = {},
    lualine_c = {'filename'},
    lualine_x = {'location'},
    lualine_y = {},
    lualine_z = {}
  },
  tabline = {},
  extensions = {}
}
EOF

" echo g:dein#plugin.name . ' hook_add loaded'
'''


# Undotree: visualize undo-tree
# ----------------------------------------
[[plugins]]
repo = 'mbbill/undotree'
lazy = true
hook_add = '''
" toggle Undotree (Sidebar Log)
nnoremap sl :UndotreeToggle<CR>

" buffer init hook
function! g:Undotree_CustomMap() abort
  nmap <buffer> ? <Plug>UndoreeHelp
  " <Plug>UndotreeFocusTarget is equal to UndotreeClose in my config
  nmap <buffer><nowait> q <Plug>UndotreeClose
  nmap <buffer><nowait> <Esc> <Plug>UndotreeClose
  nmap <buffer> <CR> <Plug>UndotreeClose
  nunmap <buffer> <Tab>
  " remove <Plug>UndotreeClearHistory
  nunmap <buffer> C
  " 't' for 'Timestamp'
  nmap <buffer> t <Plug>UndotreeTimestampToggle
  " 'd' for 'Diff'
  nmap <buffer> d <Plug>UndotreeDiffToggle
  nmap <buffer> <Up> <Plug>UndotreeNextState
  nmap <buffer> <Down> <Plug>UndotreePreviousState
  nmap <buffer> <S-Up> <Plug>UndotreeNextSavedState
  nmap <buffer> <S-Down> <Plug>UndotreePreviousSavedState
  " 'u' for <Plug>UndotreeUndo interferes with 'u' for 'Up'
  nunmap <buffer> u
  nmap <buffer> l <Plug>UndotreeUndo
  nmap <buffer> <C-r> <Plug>UndotreeRedo
  " Move to current state
  nmap <buffer> % <Plug>UndotreeEnter

  " automaticly close on WinLeave
  augroup undotree-autoclose
    autocmd!
    autocmd InsertEnter * UndotreeHide
  augroup END

endfunction

let g:undotree_SplitWidth = g:sidebar_width

" tree at the left, diff at the under
let g:undotree_WindowLayout = 2

" focus on open
let g:undotree_SetFocusWhenToggle = v:true

" clean leftover suda window from last session
"
autocmd config SessionLoadPost * silent! bdelete undotree

" echo g:dein#plugin.name . ' hook_add loaded'
'''

# Editing Region
# ----------------------------------------

# indent guides
[[plugins]]
lazy = false
repo = 'yggdroot/indentline'
hook_add = '''
let g:indentLine_char_list = ['┊']

" echo g:dein#plugin.name . ' hook_add loaded'
'''

# highlight and remode whitespaces
[[plugins]]
lazy = false
repo = 'ntpeters/vim-better-whitespace'

# color parenthesizes
[[plugins]]
repo = 'luochen1990/rainbow'
lazy = false
hook_add = '''
" 抵抗のカラーコード
let s:colorcode_gui = [
      \ '#9a4040', '#ff5e5e', '#ffaa77', '#dddd77',
      \ '#80ee80', '#66bbff', '#da6bda', '#afafaf', '#f0f0f0'
      \ ]
let s:colorcode_cterm = [ 6, 12, 6, 14, 10, 9, 13, 7, 15]

let g:rainbow_active = 1 "set to 0 if you want to enable it later via :RainbowToggle
let g:rainbow_conf = {
      \ 'guifgs' : s:colorcode_gui,
      \ 'ctermfgs' : s:colorcode_cterm,
      \ }
augroup config Colorschemes * RainbowToggleOn

" echo g:dein#plugin.name . ' hook_add loaded'
 '''

# show the color of colorcodes
[[plugins]]
repo = 'rrethy/vim-hexokinase'
lazy = false
update = 'make hexokinase'
# augroup = 'config'
# on_event = 'VimEnter'
hook_add = '''
let g:Hexokinase_highlighters = ['foreground']
" echo g:dein#plugin.name . ' hook_add loaded'
'''


# Moving Around
# ========================================
#
# # Bufstop: fast buffer switching
# # ----------------------------------------
# [[plugins]]
# repo = 'mihaifm/bufstop'
# lazy = false
# if = 'has("nvim")'
# # on_cmd = ['Bufstop', 'BufstopFast']
# hook_add = '''
# nnoremap <unique> <Leader>b :Bufstop<CR>
#
# " echo g:dein#plugin.name . ' hook_add loaded'
# '''

# TSelectBuffer: a simple buffer selector
[[plugins]]
repo = 'vim-scripts/tselectbuffer'
lazy = false
depends = 'tlib'
hook_add = '''
nnoremap <Leader>b :TSelectBuffer!<CR>

" echo g:dein#plugin.name . ' hook_add loaded'
'''

[[plugins]]
repo = 'vim-scripts/tlib'
lazy = false

# [[plugins]]
# repo = 'jlanzarotta/bufexplorer'
# lazy = false
# hook_add = '''
# let g:bufExplorerDisableDefaultKeyMapping=1    " Disable mapping.
# let g:bufExplorerShowNoName=1        " Show "No Name" buffers.
# let g:bufExplorerShowUnlisted=1      " Show unlisted buffers.
# let g:bufExplorerSplitBelow=1        " Split new window below current.
# let g:bufExplorerSplitHorzSize=5     " New split window is n rows high.

# nnoremap <silent> <Leader>b :BufExplorerHorizontalSplit<CR>

# " echo g:dein#plugin.name . ' hook_add loaded'
# '''


# [[plugins]]
# repo = 'jeetsukumaran/vim-buffergator'
# lazy = true
# on_cmd = 'BuffergatorOpen'
# hook_add = '''
# nnoremap <Leader>b :BuffergatorOpen<CR>
# nnoremap <Leader>w :BuffergatorTabsOpen<CR>

# " no default global bindings
# let g:buffergator_suppress_keymaps = v:true

# " buffer list at bottom
# let g:buffergator_viewport_split_policy = 'B'

# " let g:buffergator_autoupdate = v:true

# " hight of buffer list
# let g:buffergator_hsplit_size = 5

# function! s:buffergator_init() abort

#   " <Space> is my <Leader>
#   " nunmap <buffer> <Space>

#   " hide line numbers
#   setlocal nonumber

# endfunction
# autocmd config FileType buffergator call s:buffergator_init()

# " echo g:dein#plugin.name . ' hook_add loaded'
# '''

# jumping around the code
[[plugins]]
repo = 'easymotion/vim-easymotion'
lazy = true
if = '!has("nvim")'
hook_add = '''
let g:EasyMotion_do_mapping = v:false " Disable default mappings
" 日本語対応
let g:EasyMotion_use_migemo = 1
" move to {char}
map HH <Plug>(easymotion-bd-f)
map 2H <Plug>(easymotion-bd-f2)
" Move to word
map  Hw <Plug>(easymotion-bd-w)
" Move to line
map Hj <Plug>(easymotion-bd-jk)

" echo g:dein#plugin.name . ' hook_add loaded'
'''

[[plugins]]
repo = 'phaazon/hop.nvim'
lazy = true
if = 'has("nvim")'
on_cmd = ['HopChar1', 'HopChar2', 'HopWord', 'HopLine', 'HopPattern']
hook_add = '''
noremap f :HopChar1<CR>
noremap f2 :HopChar2<CR>
" Move to word
noremap fw :HopWord<CR>
" Move to line
noremap fl :HopLine<CR>

function s:hop_highlights() abort
  highlight link HopNextKey SpellBad
  " highlight HopNextKey term=bold cterm=bold gui=bold
  highlight link HopNextKey1 HopNextKey

  highlight link HopNextKey2 Error
  " highlight HopNextKey2 term=bold cterm=bold gui=bold

  highlight link HopUnmatched Comment
endfunction
augroup HopInitHighLight
  autocmd!
  autocmd ColorScheme * call s:hop_highlights()
augroup END

" echo g:dein#plugin.name . ' hook_add loaded'
'''
add_post_source = '''
lua << EOF
require'hop'.setup {
  -- I'll do it manualy
  hop-config-create_hl_autocmd = false
}
EOF
'''

# Vim code inspection plugin for finding definitionshammer_and_pick and references/usagesmicroscope.
[[plugins]]
repo = 'pechorin/any-jump.vim'
lazy = true
on_cmd = ['AnyJump', 'AnyJumpVisual', 'AnyBumpback', 'AnyJumpLastResults']
hook_add = '''
let g:any_jump_disable_default_keybindings = 1

" Normal mode: Jump to definition under cursor
nnoremap <leader>aj :AnyJump<CR>

" Visual mode: jump to selected text in visual mode
xnoremap <leader>aj :AnyJumpVisual<CR>

" Normal mode: open previous opened file (after jump)
nnoremap <leader>ab :AnyJumpBack<CR>

" Normal mode: open last closed search window again
nnoremap <leader>al :AnyJumpLastResults<CR>

" echo g:dein#plugin.name . ' hook_add loaded'
'''

# # smooth scrolling
# [[plugins]]
# repo = 'karb94/neoscroll.nvim'
# lazy = true
# if = 'has("nvim")'
# augroup = 'config'
# on_event = 'VimEnter'
# hook_post_source = '''
# lua << EOF
# require('neoscroll').setup({
#     -- All these keys will be mapped to their corresponding default scrolling animation
#     mappings = {'<C-u>', '<C-d>', '<C-b>', '<C-f>',
#                 '<C-y>', '<C-e>', 'zt', 'zz', 'zb'},
#     hide_cursor = true,          -- Hide cursor while scrolling
#     stop_eof = true,             -- Stop at <EOF> when scrolling downwards
#     use_local_scrolloff = false, -- Use the local scope of scrolloff instead of the global scope
#     respect_scrolloff = false,   -- Stop scrolling when the cursor reaches the scrolloff margin of the file
#     cursor_scrolls_alone = true, -- The cursor will keep on scrolling even if the window cannot scroll further
#     easing_function = nil,        -- Default easing function
#     pre_hook = nil,              -- Function to run before the scrolling animation starts
#     post_hook = nil,              -- Function to run after the scrolling animation ends
# })
# EOF
# " echo g:dein#plugin.name . ' hook_add loaded'
# '''



# Text Editing
# ========================================

# insert synmols like in lean mode of emacs, \lambda → λ
[[plugins]]
repo = 'arthurxavierx/vim-unicoder'
lazy = true

# deal with camelCase and snake_case
[[plugins]]
repo = 'chaoren/vim-wordmotion'
lazy = false

# comment out things
[[plugins]]
repo = 'tomtom/tcomment_vim'
lazy = true
on_cmd = 'TComment'
on_map = 'g'
hook_add = '''
let g:tcomment#blank_lines = 0

" echo g:dein#plugin.name . ' hook_add loaded'
'''

# align things like =
[[plugins]]
repo = 'junegunn/vim-easy-align'
lazy = true
on_map = '<Plug>(LiveEasyAlign)'
hook_add = '''
" Start interactive EasyAlign in visual mode (e.g. vipga)
xmap ga <Plug>(LiveEasyAlign)
" Start interactive EasyAlign for a motion/text object (e.g. gaip)
nmap ga <Plug>(LiveEasyAlign)
" echo g:dein#plugin.name . ' hook_add loaded'
'''

# run commands only in visual block with :<,>B
[[plugins]]
repo = 'vim-scripts/vis'
lazy = true
hook_add = '''
vnoremap : :B<Space>

" echo g:dein#plugin.name . ' hook_add loaded'
'''

# surround textobjects with parentheses
[[plugins]]
repo = 'machakann/vim-sandwich'
lazy = true
on_map = 's'
hook_post_source = '''
let g:sandwich#recipes = deepcopy(g:sandwich#default_recipes)

" echo g:dein#plugin.name . ' hook_post_source loaded'
'''

# 閉じ括弧挿入
[[plugins]]
repo = 'cohama/lexima.vim'
lazy = false
hook_add = '''
let g:lexima_enable_basic_rules = v:true
let g:lexima_enable_newline_rules = v:true
let g:lexima_enable_endwise_rules = v:true

" echo g:dein#plugin.name . ' hook_add loaded'
'''

[[plugins]]
repo = 'thinca/vim-qfreplace'
lazy = true
on_cmd = 'Qfreplace'


# Programming Languages
# ========================================

# Haskell
# ----------------------------------------
[[plugins]]
repo = 'neovimhaskell/haskell-vim'
lazy = false
# on_ft = 'haskell'

# Idris
# ----------------------------------------
[[plugins]]
repo = 'idris-hackers/idris-vim'
lazy = false
# on_ft = 'idris'
hook_add = '''
let g:idris_indent_if = 0
let g:idris_indent_case = 2
let g:idris_indent_let = 2
let g:idris_indent_where =2
let g:idris_indent_do = 2
let g:idris_indent_rewrite = 2

" echo g:dein#plugin.name . ' hook_add loaded'
'''

# Lean
# ----------------------------------------
[[plugins]]
repo = 'leanprover/lean.vim'
lazy = false
# on_ft = 'lean'

# Rust
# ----------------------------------------
[[plugins]]
repo = 'rust-lang/rust.vim'
lazy = false
# on_ft = 'rust'

# TOML.
# ----------------------------------------
[[plugins]]
repo = 'cespare/vim-toml'
lazy = false
# on_ft = 'toml'

# fish shell
# ----------------------------------------
[[plugins]]
repo = 'dag/vim-fish'
lazy = false
# on_ft = 'fish'

# R
# ----------------------------------------
[[plugins]]
repo = 'jalvesaq/Nvim-R'
lazy = false
rev = 'stable'
if = 'has("nvim")'
# on_ft = 'R'


# Language Server
# ========================================

# settings for neovim's builtin lsp client
[[plugins]]
repo = 'neovim/nvim-lspconfig'
lazy = true
if = 'has("nvim")'
depends = ['lspsaga.nvim', 'trouble.nvim', 'lsp-status.nvim', 'nvim-lsp-smag', 'folding-nvim']
augroup = 'config'
on_event = 'VimEnter'
hook_add = '''
autocmd config ColorScheme * highlight link LspCodeLens Comment
'''
hook_post_source = '''
lua << EOF
local lsp = require('lspconfig')

-- for coq_nvim
local coq = require('coq')

-- for lsp-status.nvim
local lsp_status = require('lsp-status')
lsp_status.register_progress()

-- -- Set which codelens text levels to show
-- local original_set_virtual_text = vim.lsp.diagnostic.set_virtual_text
-- local set_virtual_text_custom = function(diagnostics, bufnr, client_id, sign_ns, opts)
--     opts = opts or {}
--     -- show all messages that are Info and above (Info, Warning, Error)
--     opts.severity_limit = "Info"
--     original_set_virtual_text(diagnostics, bufnr, client_id, sign_ns, opts)
-- end

-- vim.lsp.diagnostic.set_virtual_text = set_virtual_text_custom

-- Use an on_attach function to only map the following keys
-- after the language server attaches to the current buffer
local on_attach = function(client, bufnr)
  local function buf_set_keymap(...) vim.api.nvim_buf_set_keymap(bufnr, ...) end
  local function buf_set_option(...) vim.api.nvim_buf_set_option(bufnr, ...) end

  --Enable completion triggered by <c-x><c-o>
  buf_set_option('omnifunc', 'v:lua.vim.lsp.omnifunc')

  -- Mappings.
  local opts = { noremap=true, silent=true }

  -- See `:help vim.lsp.*` for documentation on any of the below functions
  buf_set_keymap('n', 'gD', '<cmd>lua vim.lsp.buf.declaration()<CR>', opts)
  buf_set_keymap('n', 'gd', '<cmd>lua vim.lsp.buf.definition()<CR>', opts)
  buf_set_keymap('n', 'gh', '<cmd>lua vim.lsp.buf.hover()<CR>', opts)
  buf_set_keymap('n', 'gi', '<cmd>lua vim.lsp.buf.implementation()<CR>', opts)
  buf_set_keymap('n', '<C-k>', '<cmd>lua vim.lsp.buf.signature_help()<CR>', opts)
  buf_set_keymap('n', '<Leader>wa', '<cmd>lua vim.lsp.buf.add_workspace_folder()<CR>', opts)
  buf_set_keymap('n', '<Leader>wr', '<cmd>lua vim.lsp.buf.remove_workspace_folder()<CR>', opts)
  buf_set_keymap('n', '<Leader>wl', '<cmd>lua print(vim.inspect(vim.lsp.buf.list_workspace_folders()))<CR>', opts)
  buf_set_keymap('n', '<Leader>D', '<cmd>lua vim.lsp.buf.type_definition()<CR>', opts)
  buf_set_keymap('n', '<Leader>rn', '<cmd>lua vim.lsp.buf.rename()<CR>', opts)
  buf_set_keymap('n', 'z=', '<cmd>lua vim.lsp.buf.code_action()<CR>', opts)
  buf_set_keymap('n', 'gr', '<cmd>lua vim.lsp.buf.references()<CR>', opts)
  buf_set_keymap('n', '<Leader>e', '<cmd>lua vim.lsp.diagnostic.show_line_diagnostics()<CR>', opts)
  buf_set_keymap('n', '[d', '<cmd>lua vim.lsp.diagnostic.goto_prev()<CR>', opts)
  buf_set_keymap('n', ']d', '<cmd>lua vim.lsp.diagnostic.goto_next()<CR>', opts)
  buf_set_keymap('n', '<Leader>q', '<cmd>lua vim.lsp.diagnostic.set_loclist()<CR>', opts)
  buf_set_keymap('n', '<Leader>f', '<cmd>lua vim.lsp.buf.formatting()<CR>', opts)
  buf_set_keymap('n', '<Leader>l', '<Cmd>lua vim.lsp.codelens.run()<CR>', opts)
  vim.cmd([[
    augroup codelens
      autocmd!
      autocmd CursorHold,CursorHoldI,InsertLeave <buffer> lua vim.lsp.codelens.refresh()
    augroup END
  ]])
  lsp_status.on_attach(client, buffer)
  require('folding').on_attach() -- for code folding
end

lsp.hls.setup(coq.lsp_ensure_capabilities{

  settings = {
    haskell = {
      completionSnippetsOn = false,
    }
  },
  on_attach = on_attach,
  capability = lsp_status.capability,
  cmd = { "haskell-language-server-wrapper", "--lsp" },
})

lsp.elmls.setup(coq.lsp_ensure_capabilities{
  on_attach = on_attach,
  capability = lsp_status.capability
})

lsp.yamlls.setup(coq.lsp_ensure_capabilities{
  on_attach = on_attach,
  capability = lsp_status.capability
})

EOF

" echo g:dein#plugin.name . ' hook_add loaded'
'''
# format on save
[ftplugin]
hs = '''
autocmd config BufWritePre *.hs lua vim.lsp.buf.formatting_sync(nil, 1000)
autocmd config BufWritePre *.hs.in lua vim.lsp.buf.formatting_sync(nil, 1000)
'''
elm = '''
autocmd config BufWritePre *.elm lua vim.lsp.buf.formatting_sync(nil, 1000)
autocmd config BufWritePre *.elm.in lua vim.lsp.buf.formatting_sync(nil, 1000)
'''


# Coq: Fast as FUCK nvim completion.
# ----------------------------------------
[[plugins]]
repo = 'ms-jpq/coq_nvim'
post_update = 'COQdeps'
if = 'has("nvim")'
lazy = false
depends = 'coc.artifacts'
hook_add = '''
let g:coq_settings = { 'auto_start': v:true }

" echo g:dein#plugin.name . ' hook_add loaded'
'''

# 9000+ Snippets
[[plugins]]
repo = 'ms-jpq/coq.artifacts'
rev = 'artifacts'
if = 'has("nvim")'
lazy = true
depends = 'coq_nvim'

# integrate with tagfunc
[[plugins]]
repo = 'weilbith/nvim-lsp-smag'
lazy = true
if = 'has("nvim")'
depends = 'nvim-lspconfig'


[[plugins]]
repo = 'pierreglaser/folding-nvim'
lazy = true
depends = 'nvim-lspconfig'


# UI for LSP
# ----------------------------------------

[[plugins]]
repo = 'glepnir/lspsaga.nvim'
lazy = true
if = 'has("nvim")'
depends = 'nvim-lspconfig'
hook_post_source = '''
lua << EOF
local saga = require 'lspsaga'

saga.init_lsp_saga {
  -- default value
  -- use_saga_diagnostic_sign = true
  -- error_sign = '',
  -- warn_sign = '',
  -- hint_sign = '',
  -- infor_sign = '',
  -- dianostic_header_icon = '   ',
  code_action_icon = '',
  -- code_action_prompt = {
  --   enable = true,
  --   sign = true,
  --   sign_priority = 20,
  --   virtual_text = true,
  -- },
  -- finder_definition_icon = '  ',
  -- finder_reference_icon = '  ',
  -- max_preview_lines = 10, -- preview lines of lsp_finder and definition preview
  -- finder_action_keys = {
  --   open = 'o', vsplit = 's',split = 'i',quit = 'q',scroll_down = '<C-f>', scroll_up = '<C-b>' -- quit can be a table
  -- },
  -- code_action_keys = {
  --   quit = 'q',exec = '<CR>'
  -- },
  -- rename_action_keys = {
  --   quit = '<C-c>',exec = '<CR>'  -- quit can be a table
  -- },
  -- definition_preview_icon = '  '
  -- -- "single" "double" "round" "plus"
  -- border_style = "single"
  -- rename_prompt_prefix = '➤',
  -- if you don't use nvim-lspconfig you must pass your server name and
  -- the related filetypes into this table
  -- like server_filetype_map = {metals = {'sbt', 'scala'}}
  -- server_filetype_map = {}
}

EOF
" echo g:dein#plugin.name . ' hook_post_source loaded'
'''

# A pretty list for showing diagnostics, references, telescope results, quickfix and location lists
[[plugins]]
repo = 'folke/trouble.nvim'
lazy = true
depends = ['nvim-lspconfig', 'nvim-web-devicons']
hook_post_source = '''
lua << EOF
require('trouble').setup{}
EOF

" echo g:dein#plugin.name . ' hook_add loaded'
'''

# lsp-status.nvim: statusline
[[plugins]]
repo = 'nvim-lua/lsp-status.nvim'
lazy = true
depends = 'nvim-lspconfig'
if = 'has("nvim")'


# Development
# ----------------------------------------

[[plugins]]
repo = 'nvim-treesitter/nvim-treesitter'
lazy = true
if = 'has("nvim")'
on_ft = ['vim']
post_update = 'TSUpdate'

# debugger
[[plugins]]
repo = 'puremourning/vimspector'
lazy = true
hook_add = '''
let g:vimspector_enable_mappings = 'VISUAL_STUDIO'

" echo g:dein#plugin.name . ' hook_add loaded'
'''


# Git
# ========================================

# git情報を左に表示
[[plugins]]
repo = 'airblade/vim-gitgutter'
lazy = false
# hook_add = '''
# " echo g:dein#plugin.name . ' hook_add loaded'
# '''

[[plugins]]
repo = 'tpope/vim-fugitive'
lazy = true
on_cmd = 'Git'

[[plugins]]
repo = 'TimUntersberger/neogit'
lazy = true
if = 'has("nvim")'
on_cmd = 'Neogit'
depends = 'plenary.nvim'
hook_add = '''
nnoremap <Leader>g :Neogit<CR>
" echo g:dein#plugin.name . ' hook_post_source loaded'
'''
hook_post_source = '''
lua << EOF
require('neogit').setup{}
EOF

" echo g:dein#plugin.name . ' hook_post_source loaded'
'''

[[plugins]]
repo = 'nvim-lua/plenary.nvim'
lazy = true
if = 'has("nvim")'


# [[plugins]]
# repo = 'tpope/vim-fugitive'
# lazy = true
# hook_add = '''

# " echo g:dein#plugin.name . ' hook_post_source loaded'
# '''

# Miscellaneous
# ========================================

# キーバインドを表示
[[plugins]]
repo = 'liuchengxu/vim-which-key'
lazy = false
if = '!has("nvim")'

[[plugins]]
repo = 'folke/which-key.nvim'
lazy = true
if = 'has("nvim")'
augroup = 'config'
on_event = 'VimEnter'
hook_post_source = '''

noremap ? :WhichKey<CR>

lua << EOF
require('which-key').setup {
    -- your configuration comes here
    -- or leave it empty to use the default settings
    -- refer to the configuration section below
    plugins = {
      spelling = {
        enabled = true, -- enabling this will show WhichKey when pressing z= to select spelling suggestions
      },
    },
  }
EOF

" echo g:dein#plugin.name . ' hook_post_source loaded'
'''

# edit with sudo
[[plugins]]
repo = 'lambdalisue/suda.vim'
lazy = false
hook_add = '''
let g:suda_smart_edit = 1

" clean leftover suda window from last session
autocmd config SessionLoadPost * silent! bdelete suda

" echo g:dein#plugin.name . ' hook_add loaded'
'''


# 現在のカーソル位置のコンテキストによって filetype を切り換える為のプラグイン
[[plugins]]
repo = 'osyo-manga/vim-precious'
lazy = true
depends = 'context_filetype.vim'
on_ft = ['vim', 'help', 'toml']
hook_add = '''
" " NORMALモードのカーソル移動中に頻繁に切り替わるとうざいのでデフォは無効化しておく(helpは例外)
" let g:precious_enable_switch_CursorMoved = { '*': 0, 'help': 1, 'git': 1}

" " INSERTモードのON／OFFに合わせてトグル
" autocmd config InsertEnter * PreciousSwitch
" autocmd config InsertLeave * PreciousReset

" " echo g:dein#plugin.name . ' hook_add loaded'
'''

# カーソル位置のコンテキストのftを判定するライブラリ
[[plugins]]
repo = 'Shougo/context_filetype.vim'
lazy = false

